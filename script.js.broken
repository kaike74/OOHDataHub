
// ===================================
// GLOBAL VARIABLES
// ===================================

let map;
let markers = [];
let currentPoints = []; // Store loaded points data
const API_BASE_URL = 'https://ooh-system.kaike-458.workers.dev';

// Brazilian state name to code mapping
const brazilStates = {
    'Acre': 'AC', 'Alagoas': 'AL', 'Amapá': 'AP', 'Amazonas': 'AM',
    'Bahia': 'BA', 'Ceará': 'CE', 'Distrito Federal': 'DF',
    'Espírito Santo': 'ES', 'Goiás': 'GO', 'Maranhão': 'MA',
    'Mato Grosso': 'MT', 'Mato Grosso do Sul': 'MS', 'Minas Gerais': 'MG',
    'Pará': 'PA', 'Paraíba': 'PB', 'Paraná': 'PR', 'Pernambuco': 'PE',
    'Piauí': 'PI', 'Rio de Janeiro': 'RJ', 'Rio Grande do Norte': 'RN',
    'Rio Grande do Sul': 'RS', 'Rondônia': 'RO', 'Roraima': 'RR',
    'Santa Catarina': 'SC', 'São Paulo': 'SP', 'Sergipe': 'SE', 'Tocantins': 'TO'
};

// ===================================
// INITIALIZATION
// ===================================

document.addEventListener('DOMContentLoaded', () => {
    initMap();
    loadExibidoras();
    renderProductList(); // Initialize empty product list
});

// ===================================
// MAP INITIALIZATION
// ===================================

function initMap() {
    // Initialize Leaflet map centered on Brazil
    map = L.map('map').setView([-15.7801, -47.9292], 4);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
    }).addTo(map);

    // Load existing points
    loadPoints();
}

// ===================================
// LOAD POINTS FROM API
// ===================================

async function loadPoints() {
    try {
        const response = await fetch(`${API_BASE_URL}/api/ooh`);

        if (!response.ok) {
            throw new Error('Erro ao carregar pontos');
        }

        currentPoints = await response.json();

        // Clear existing markers
        markers.forEach(marker => marker.remove());
        markers = [];

        // Add markers for each point
        if (currentPoints.length > 0) {
            const bounds = [];

            currentPoints.forEach(point => {
                if (point.latitude && point.longitude) {
                    const marker = L.marker([point.latitude, point.longitude], {
                        icon: createCustomIcon()
                    }).addTo(map);

                    // Click event to open drawer instead of popup
                    marker.on('click', () => {
                        openDrawer(point);
                    });

                    markers.push(marker);
                    bounds.push([point.latitude, point.longitude]);
                }
            });

            // Fit map to show all markers
            if (bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }
    } catch (error) {
        console.error('Erro ao carregar pontos:', error);
        alert('Não foi possível carregar os pontos. Verifique sua conexão e tente novamente.');
    }
}

// ===================================
// CUSTOM MARKER ICON
// ===================================

function createCustomIcon() {
    return L.icon({
        iconUrl: 'data:image/svg+xml;base64,' + btoa(`
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32">
                <path fill="#2563eb" d="M12 0C7.802 0 4 3.403 4 7.602C4 11.8 7.469 16.812 12 24C16.531 16.812 20 11.8 20 7.602C20 3.403 16.199 0 12 0z"/>
                <circle cx="12" cy="8" r="3" fill="white"/>
            </svg>
        `),
        iconSize: [32, 32],
        iconAnchor: [16, 32],
        popupAnchor: [0, -32]
    });
}

// ===================================
// DETAILS DRAWER
// ===================================

const drawer = document.getElementById('details-drawer');
const closeDrawerBtn = document.getElementById('close-drawer');
const editPointBtn = document.getElementById('edit-point-btn');
const drawerExhibitorSection = document.getElementById('drawer-exhibitor-section');

// Drawer elements
const drawerCode = document.getElementById('drawer-code');
const drawerAddress = document.getElementById('drawer-address');
const drawerCity = document.getElementById('drawer-city');
const drawerMeasures = document.getElementById('drawer-measures');
const drawerFlow = document.getElementById('drawer-flow');
const drawerExhibitor = document.getElementById('drawer-exhibitor');
const drawerProducts = document.getElementById('drawer-products');
const drawerImages = document.getElementById('drawer-images');
const carouselDots = document.getElementById('carousel-dots');
const prevImageBtn = document.getElementById('prev-image');
const nextImageBtn = document.getElementById('next-image');

let currentDrawerPoint = null;
let currentImageIndex = 0;
let drawerImagesList = [];

function openDrawer(point) {
    currentDrawerPoint = point;

    // Populate basic info
    drawerCode.textContent = point.codigo_ooh || '-';
    drawerAddress.textContent = point.endereco || '-';
    drawerCity.textContent = `${point.cidade || ''} - ${point.uf || ''}`;
    drawerMeasures.textContent = point.medidas || '-';
    drawerFlow.textContent = point.fluxo || '-';
    drawerExhibitor.textContent = point.exibidora_nome || 'N/A';

    // Populate products
    let productsHtml = '<div class="product-list-empty">Nenhum produto cadastrado</div>';

    // Try to parse products JSON or handle legacy data
    try {
        // Note: The API currently returns products as a JSON string in the 'produtos' column
        // But we also have a separate 'produtos' table. For now, let's use what's available.
        // If the point has a 'produtos' field that is a JSON string array of types
        if (point.produtos) {
            let productsData = [];
            try {
                productsData = JSON.parse(point.produtos);
            } catch (e) {
                productsData = [point.produtos]; // Treat as single string if parse fails
            }

            if (Array.isArray(productsData) && productsData.length > 0) {
                productsHtml = productsData.map(p => `
                    <div class="product-item">
                        <div class="product-item-info">
                            <div class="product-item-name">${p}</div>
                        </div>
                    </div>
                `).join('');
            }
        }
    } catch (e) {
        console.error('Error parsing products:', e);
    }
    drawerProducts.innerHTML = productsHtml;

    // Setup Images Carousel
    setupCarousel(point);

    // Open drawer
    drawer.classList.add('active');
}

function closeDrawer() {
    drawer.classList.remove('active');
    if (products.some(p => p.tipo === tipo)) {
        alert('Este tipo de produto já foi adicionado');
        return;
    }

    // Determine período
    const periodo = tipo === 'Locação' ? produtoPeriodoSelect.value : 'Unitário';

    // Add to list
    products.push({ tipo, valor, periodo });

    // Render list
    renderProductList();

    // Clear inputs
    produtoTipoSelect.value = '';
    produtoValorInput.value = '';
    produtoPeriodoSelect.value = 'Mensal';
    produtoPeriodoField.style.display = 'none';
});

// Remove product from list
window.removeProduct = function (index) {
    products.splice(index, 1);
    renderProductList();
};

// Render product list
function renderProductList() {
    if (products.length === 0) {
        productListContainer.innerHTML = '<div class="product-list-empty">Nenhum produto adicionado</div>';
        return;
    }

    productListContainer.innerHTML = products.map((product, index) => {
        const periodoText = product.periodo !== 'Unitário' ? ' - ' + product.periodo : '';
        return `<div class="product-item">
            <div class="product-item-info">
                <div class="product-item-name">${product.tipo}</div>
                <div class="product-item-details">R$ ${product.valor.toFixed(2).replace('.', ',')}${periodoText}</div>
            </div>
            <button type="button" class="product-remove-btn" onclick="removeProduct(${index})">Remover</button>
        </div>`;
    }).join('');
}

// ===================================
// FORM SUBMISSION (OOH)
// ===================================

const form = document.getElementById('form-cadastro');

form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const submitBtn = document.getElementById('submit-btn');
    const originalBtnText = submitBtn.innerHTML;

    try {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span>Cadastrando...</span>';

        // Prepare FormData
        const formData = new FormData();

        // Basic fields
        formData.append('codigo_ooh', document.getElementById('codigo_ooh').value);
        formData.append('id_exibidora', exibidoraSelect.value);
        formData.append('endereco', document.getElementById('endereco').value);
        formData.append('ponto_referencia', document.getElementById('ponto_referencia').value);
        formData.append('streetview_embed', document.getElementById('streetview_embed').value);
        formData.append('latitude', document.getElementById('latitude').value);
        formData.append('longitude', document.getElementById('longitude').value);
        formData.append('cidade', document.getElementById('cidade').value);
        formData.append('uf', document.getElementById('uf').value);
        formData.append('medidas', document.getElementById('medidas').value);
        formData.append('fluxo', document.getElementById('fluxo').value);
        formData.append('observacoes', document.getElementById('observacoes').value);

        // Products (checkboxes - legacy)
        const produtosCheckboxes = Array.from(document.querySelectorAll('input[name="produtos"]:checked'))
            .map(cb => cb.value);

        // Combine legacy checkboxes with new product system for 'produtos' field
        // Ideally we should move away from checkboxes if we have the new system
        // For now, let's send the new products array as JSON
        formData.append('produtos', JSON.stringify(products.map(p => p.tipo)));

        // Also send the full products data with prices for the backend to handle
        // We'll send this as a separate field or handle it in the backend
        // The current backend expects 'produtos' as a JSON array of strings and 'valor' as a single value
        // We need to update the backend to handle the new structure, but for now let's adapt:

        // If we have products, use the first one's value as the main value (fallback)
        if (products.length > 0) {
            formData.append('valor', products[0].valor);
        }

        // Image
        const imageFile = imageInput.files[0];
        if (imageFile) {
            formData.append('imagem', imageFile);
        }

        // Submit form
        const response = await fetch(`${API_BASE_URL}/api/ooh`, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Erro ao cadastrar ponto');
        }

        const data = await response.json();

        // Success!
        alert('Ponto cadastrado com sucesso!');
        closeModal();
        loadPoints(); // Reload map points

    } catch (error) {
        console.error('Erro ao cadastrar ponto:', error);
        alert('Erro ao cadastrar ponto: ' + error.message);
    } finally {
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnText;
    }
});

// ===================================
// RESET FORM
// ===================================

function resetForm() {
    form.reset();
    imagePreviewContainer.style.display = 'none';
    fileNameSpan.textContent = 'Escolher arquivo';
    products = []; // Clear products list
    renderProductList();
}

// ===================================
// LOAD EXHIBITORS
// ===================================

async function loadExibidoras() {
    try {
        const response = await fetch(`${API_BASE_URL}/api/exibidoras`);
        if (!response.ok) throw new Error('Erro ao carregar exibidoras');
        const exibidoras = await response.json();

        while (exibidoraSelect.options.length > 2) {
            exibidoraSelect.remove(2);
        }

        exibidoras.forEach(exibidora => {
            const option = document.createElement('option');
            option.value = exibidora.id;
            option.textContent = exibidora.nome;
            exibidoraSelect.appendChild(option);
        });
    } catch (error) {
        console.error('Erro ao carregar exibidoras:', error);
    }
}
